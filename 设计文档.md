# 设计文档
## 架构设计图
![alt 架构图](./arch.svg)
## 总体架构分析
* 消息通信协议
  * 采用 `grpc` 协议作为服务器之间通信的消息协议
* 服务发现与注册
  * 使用 `etcd` 进行服务发现、注册与保活
* 动态键值路由储存
  * 使用 `redis cluster` 三主三从模式进行动态键值路由数据的储存
* 性能监控
  * 使用 `prometheus` 进行指标监控
  * 使用 `grafana` 进行数据指标可视化
## `grpc` 路由架构分析
`grpc` 官方提供了基本的服务发现和负载均衡策略，同时提供相应的扩展接口用于支持开发者开发自定义的服务发现与负载均衡
* `Resolver` 负责解析请求，将目标地址解析为一个或多个 `IP` 地址，并按需生成相关配置
* `Balancer` 为每个地址创建一个子通道 `channel`，并监测每一个子通道状态
* 当发起 `RPC` 请求，`Balancer` 通过 `Picker` 选择一个子通道，当可用服务器为空时，客户端的请求将被阻塞

在本项目中，主要通过对 `Resolver` 与 `Picker` 进行重写，从而实现对于 `grpc` 请求的自定义路由转发
## 路由格式设计
```go
type Endpoint struct {
	Name      string // 服务名称，如 chatsvr、matchsvr
	Namespace string // 名字空间，如生产环境、测试环境
	IP        string // IP 地址
	Port      string // 端口
	Weight    int // 权重，用于权重随机路由
	Wants     []*Match // 用于动态路由的匹配规则
	WantsType WantsType // 用于动态路由的匹配类型
}
```
* `Name` 字段为服务名称，如 `chatsvr` `matchsvr` `fightsvr` 等
* `Namespace` 字段主要用于环境隔离，如区分生产与测试环境
* `Weight` 字段用于权重随机路由中配置服务器权重
* `Wants` 字段为动态路由时的服务器匹配规则
* `WantsType` 字段为动态路由时的服务器匹配类型
  * 满足所有规则
  * 满足至少一条规则
  * 不满足所有规则
  * 至少不满足一种规则

`Match` 规则具体结构如下
```go
type Match struct {
	MatchType MatchType // 匹配类型
	Pattern   string // 匹配目标
} 
```
* `MathchType` 字段指定了匹配的类型
  * 前缀匹配
  * 精确匹配
  * 正则匹配
* `Pattern` 字段指定了匹配的目标
  * 前缀匹配时，为前缀
  * 精确匹配时，为完整字符串
  * 正则匹配时，为一个正则表达式
## `Resolver` 实现
在本项目中，`Resolver` 由 `dicovery` 模块实现，同时集成了 `etcd` 的服务发现功能以及 `grpc` 请求的名字解析功能
```go
// ServiceDiscovery 服务发现与名字解析
type ServiceDiscovery struct {
	cli        *clientv3.Client // etcd 客户端
	cc         resolver.ClientConn // grpc resolver
	serverList map[string]*sync.Map // 前缀 - 地址列表
	config     *config.Config // 配置文件
}
// NewServiceDiscovery  新建发现服务
NewServiceDiscovery(configPath string)
// Build 为给定目标创建一个新的`resolver`，当调用`grpc.Dial()`时执行
Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) 
// ResolveNow 监视目标更新
ResolveNow(rn resolver.ResolveNowOptions)
// Scheme return schema
Scheme()
// watcher 监听前缀
watcher(prefix string)
// SetServiceList 新增服务地址
SetServiceList(prefix, key, val string)
// DelServiceList 删除服务地址
DelServiceList(prefix, key string)
// 根据配置文件进行初始化
Init(configPath string)
```
使用方法如下
```go
etcd.Init(*configPath)
conn, err := grpc.NewClient(
    "grpclb:///chatsvr", 
    grpc.WithTransportCredentials(insecure.NewCredentials()), 
    grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"mybalancer"}`)
)
```
其中，通过 `Init` 函数并传入配置文件路径进行初始化设置（将会自动在 `grpc.resolver` 中进行注册），`target` 格式为 `grpclb:///` + 服务名称，而 `balancer` 参数将在下一节进行介绍，其大致工作流程如下
* 调用 `Init` 函数之后，将会根据配置文件连接至 `etcd` 服务器
* 新建 `grpc` 连接时，将解析出前缀，并对 `etcd` 中的前缀进行监听，如发生变更，则调用 `UpdateState` 函数进行地址列表的更新
## `Balancer` 实现
在本项目中，`Balancer` 采用默认的 `base.balancer` 实现，主要是对 `Picker` 进行了功能实现
```go
type myPickerBuilder struct {
	blcs map[string]MyBalancer // 根据配置文件加载的均衡负载器：服务名 - 均衡负载器
}
type myPicker struct {
	subConns map[*router.Endpoint]balancer.SubConn // 连接子通道
	blc      MyBalancer // 均衡负载器
}
// 地址列表发生变更时调用，将返回一个 picker
func (r *myPickerBuilder) Build(info base.PickerBuildInfo)
// 负责选择出一个用于连接的子通道
func (p *myPicker) Pick(info balancer.PickInfo)
// 根据配置文件进行初始化
func Init(configPath string) 
```
使用时,先通过 `Init` 函数进行初始化
```go
mybalancer.Init(*configPath)
```
再在 `grpc` 的连接选项中加上以下内容即可
```go
grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"mybalancer"}`)
```
其大致工作流程如下
* 调用 `Init` 函数之后，将会根据配置文件配置各个服务器的均衡负载器（将会自动在 `grpc.balancer` 中进行注册）
* 当地址列表发生变更时调用，调用 `Build` 将返回一个 `picker`
* 调用 `Pick` 函数选择一个子通道进行连接

## 均衡负载器设计
```go
type MyBalancer interface {
	Init(*config.Config, string) // 初始化
	Pick(ctx context.Context) *router.Endpoint // 选择路由
	Add(*router.Endpoint) // 新增路由
	Remove(*router.Endpoint) // 移除路由
	Reset() // 重置
	GetAll() []*router.Endpoint // 获取所有路由
	GetType() MyBalancerType
}
```
任何实现了 `MyBalancer` 接口的实体，均可以作为均衡负载器使用，在使用时，只需要在 `MyBalancerFactory` 中进行注册即可
```go
func MyBalancerFactory(config *config.Config) map[string]MyBalancer {
	blc := map[string]MyBalancer{}
	for svrName, rule := range config.Balancer.Rules {
		switch rule.BalancerType {
		case "random":
			blc[svrName] = &RandomBalancer{}
		case "weight":
			blc[svrName] = &WeightBalancer{}
		case "consistent-hash":
			blc[svrName] = &ConsistentHashBalancer{}
		case "dynamic":
			blc[svrName] = &DynamicBalancer{}
		default:
			log.Fatal("invalid balancer type")
		}
		blc[svrName].Init(config, svrName)
	}
	return blc
}
```
由于采用了接口式设计，因此 `Pick` 函数的代码极为简洁，只需要调用均衡负载器的 `Pick` 方法即可
```go
func (p *myPicker) Pick(info balancer.PickInfo) (balancer.PickResult, error) {
	ep := p.blc.Pick(info.Ctx)
	return balancer.PickResult{
		SubConn: p.subConns[ep],
	}, nil
}
```
## 动态键值路由设计
在本项目中，所有的动态路由数据将会储存在一个三主三从的 `redis cluster` 中，需在配置文件中进行配置
```yaml
redis:
  addrs:
    - "localhost:9001"
    - "localhost:9002"
    - "localhost:9003"
    - "localhost:9004"
    - "localhost:9005"
    - "localhost:9006"
  username: ""
  password: ""
  dial_timeout: 5s
  read_timeout: 3s
  write_timeout: 3s
```
当发起请求时，首先从 `redis cluster` 中拉取路由信息，并判断路由信息是否合法（服务器是否存在、是否符合服务器的规则）；若不存在或不符合规则，则遍历当前服务器列表，找出第一个符合规则的服务器，写入 `redis cluster` 后返回连接；若不存在符合要求的服务器，则阻塞，直到有能够符合规则的新服务器加入
## 有状态路由使用（一致性哈希、动态键值路由）
在调用 `grpc` 方法时，需要在 `ctx` 中传入对应的参数
* 一致性哈希，传入用于哈希的键值
* 动态键值路由，传入用于匹配服务器路由规则的键值
```go
ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs("hash-key", "your hash key"))
reply, err := client.YourMethod(ctx, &pb.Request{
    ...
})

ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs("user-id", "your dynamic key"))
reply, err := client.YourMethod(ctx, &pb.Request{
    ...
})
```
其中，`hash-key` `user-id` 等标识符可以在配置文件中进行配置
## 配置文件设计
* `etcd` 配置
```yaml
etcd:
  endpoints:
    - localhost:2379
  dial_timeout: 5s
  username: ""
  password: ""
```
* `balancer` 配置（均衡负载器）
```yaml
balancer:
  rules:
    "matchsvr":
      balancer_type: "consistent-hash" # 一致性哈希路由
      namespace: "produce" # 需要监听的名字空间
      consistent_hash_config: # 一致性哈希配置
        hash_func: "crc32" # 哈希函数
        replicas: 1000 # 每个节点在哈希环上的副本数量
        key: "hash-key" # 用于哈希的 key 名字
    "chatsvr":
      balancer_type: "dynamic" # 动态键值路由
      namespace: "produce" # 名字空间
      dynamic_config: # 动态键值路由配置
        expire: 0s # 路由在 redis cluster 中的过期时间，0s 代表永不过期
        key: "user-id" # 用于匹配服务器路由规则的 key 名字
    "fightsvr":
      balancer_type: "random" # 随机路由
      namespace: "produce" # 名字空间
    "mailsvr":
      balancer_type: "weight" # 随机权重路由
      namespace: "produce" # 名字空间
```
* 服务器配置
```yaml
server:
  "chatsvr-1":
    endpoint:
      name: "chatsvr" # 服务名称
      namespace: "produce" # 所属的名字空间
      ip: "localhost"
      port: "50051"
      weight: 1 # 权重
      wants_type: all_match # 满足全部匹配规则
      wants:
        - match_type: prefix # 前缀匹配
          pattern: "user1" # 匹配目标
    lease: 1 # 向 etcd 服务器的续租间隔
```